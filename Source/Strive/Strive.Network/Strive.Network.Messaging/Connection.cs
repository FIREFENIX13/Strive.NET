using System;
using System.Collections.Concurrent;
using System.Net;
using System.Net.Sockets;
using System.Threading;
using Common.Logging;
using Strive.Network.Messages;
using UpdateControls;


namespace Strive.Network.Messaging
{
    public enum ConnectionStatus
    {
        Connecting,
        Connected,
        Disconnected
    }

    public class MessageEventArgs : EventArgs
    {
        public object Message { get; private set; }
        public MessageEventArgs(object message)
        {
            Message = message;
        }
    }

    public class Connection
    {
        private ConnectionStatus _status;

        // TODO: does updatecontrols belong in here?
        #region Independent properties
        // Generated by Update Controls --------------------------------
        private readonly Independent _indStatus = new Independent();

        public ConnectionStatus Status
        {
            get { _indStatus.OnGet(); return _status; }
            private set { _indStatus.OnSet(); _status = value; }
        }
        // End generated code --------------------------------
        #endregion

        BlockingCollection<object> _messageInQueue;
        BlockingCollection<object> _messageOutQueue;

        protected Socket TcpSocket;
        readonly byte[] _tcpbuffer = new byte[MessageTypeMap.BufferSize];  // Receive buffer.
        int _tcpOffset;

        public event EventHandler Connect;
        public event EventHandler ConnectFailed;
        public event EventHandler Disconnect;
        public event EventHandler MessageRecieved;

        protected ILog Log;
        public Connection()
        {
            Status = ConnectionStatus.Disconnected;
            Log = LogManager.GetCurrentClassLogger();
        }

        public void Start(Socket socket)
        {
            lock (lockObject)
            {
                TcpSocket = socket;
                _tcpOffset = 0;
                Status = ConnectionStatus.Connected;
                _messageInQueue = new BlockingCollection<object>();
                _messageOutQueue = new BlockingCollection<object>();
                BeginReading();
                BeginSending();
            }
        }

        public void Start(IPEndPoint remoteEndPoint)
        {
            lock (lockObject)
            {
                if (TcpSocket != null)
                    Stop();

                // Connect to the remote endpoint.
                TcpSocket = new Socket(remoteEndPoint.AddressFamily, SocketType.Stream, ProtocolType.Tcp);
                try
                {
                    TcpSocket.BeginConnect(remoteEndPoint, ConnectTcpCallback, this);
                }
                catch (SocketException se)
                {
                    Log.Error("Error connecting, closing connection.", se);
                    Stop();
                    if (ConnectFailed != null)
                        ConnectFailed(this, null);
                    return;
                }

                Status = ConnectionStatus.Connecting;
            }
        }

        public void Stop()
        {
            lock (lockObject)
            {
                if (_messageOutQueue != null)
                    _messageInQueue.CompleteAdding();
                if (_messageOutQueue != null)
                    _messageOutQueue.CompleteAdding();

                if (TcpSocket != null && Status != ConnectionStatus.Disconnected)
                {
                    try
                    {
                        TcpSocket.Shutdown(SocketShutdown.Both);
                        TcpSocket.Close();
                    }
                    catch (SocketException se)
                    {
                        Log.Error("Error shutting down", se);
                    }
                }
                TcpSocket = null;

                if (Status == ConnectionStatus.Connected && Disconnect != null)
                    Disconnect(this, null);
                Status = ConnectionStatus.Disconnected;

                _messageInQueue = null;
                _messageOutQueue = null;
            }
        }

        private static void ConnectTcpCallback(IAsyncResult ar)
        {
            var client = (Connection)ar.AsyncState;
            lock (client.lockObject)
            {
                try
                {
                    // Complete the connection.
                    client.TcpSocket.EndConnect(ar);
                }
                catch (SocketException se)
                {
                    client.Log.Error("Error connecting, closing connection.", se);
                    client.Stop();
                    if (client.ConnectFailed != null)
                        client.ConnectFailed(client, null);
                    return;
                }

                // Start reading/writing
                client.Start(client.TcpSocket);

                client.Log.Info("Connected to " + client.TcpSocket.RemoteEndPoint);
                if (client.Connect != null)
                    client.Connect(client, null);
            }
        }

        private void BeginReading()
        {
            lock (lockObject)
            {
                // Begin reading
                try
                {
                    TcpSocket.BeginReceive(
                        _tcpbuffer, 0, MessageTypeMap.BufferSize, 0,
                        new AsyncCallback(ReceiveTcpCallback), this);
                }
                catch (SocketException e)
                {
                    Log.Error("Error receiving, closing connection.", e);
                    Stop();
                    return;
                }
            }
        }

        private static void ReceiveTcpCallback(IAsyncResult ar)
        {
            // Retrieve the state object and the client socket 
            // from the async state object.
            var client = (Connection)ar.AsyncState;
            lock (client.lockObject)
            {
                if (client.TcpSocket == null)
                    return;

                int bytesRead;
                try
                {
                    // Read data from the remote device.
                    bytesRead = client.TcpSocket.EndReceive(ar);
                }
                catch (ArgumentException)
                {
                    // this is the result of a previous connection, we discard it
                    return;
                }
                catch (SocketException e)
                {
                    client.Log.Error("Error reading, closing connection.", e);
                    client.Stop();
                    return;
                }

                if (bytesRead == 0)
                {
                    client.Log.Info("Connection closed by remote.");
                    client.Stop();
                    return;
                }

                client._tcpOffset += bytesRead;
                while (client._tcpOffset > MessageTypeMap.MessageLengthLength)
                {
                    int expectedLength = BitConverter.ToInt16(client._tcpbuffer, 0);

                    if (client._tcpOffset >= expectedLength)
                    {
                        object message;
                        try
                        {
                            message = CustomFormatter.Deserialize(client._tcpbuffer);
                        }
                        catch (Exception e)
                        {
                            client.Log.Error("Invalid packet received, closing connection.", e);
                            client.Stop();
                            return;
                        }
                        if (client._messageInQueue.TryAdd(message))
                        {
                            client.Log.Trace("enqueued " + message.GetType() + " message");
                            if (client.MessageRecieved != null) client.MessageRecieved(client, new MessageEventArgs(message));
                        }
                        else
                        {
                            client.Log.Error("Failed to enqueue " + message.GetType() + " message");
                        }

                        // copy the remaining data to the front of the buffer
                        client._tcpOffset -= expectedLength;
                        if (client._tcpOffset > 0)
                            Array.Copy(client._tcpbuffer, expectedLength, client._tcpbuffer, 0, client._tcpOffset);
                    }
                }

                // listen for the next message
                client.BeginReading();
            }
        }

        private object lockObject = new object();
        public virtual bool Send(object message)
        {
            lock (lockObject)
            {
                if (Status != ConnectionStatus.Connected)
                {
                    Log.Trace("Not connected, cannot send " + message.GetType() + " message");
                    return false;
                }
                if (!_messageOutQueue.TryAdd(message))
                {
                    Log.Error("Failed to enqueue " + message.GetType() + " message");
                    return false;
                }
                return true;
            }
        }

        private void BeginSending()
        {
            (new Thread(SendMessage)).Start();
        }

        private void SendMessage()
        {
            object message;
            var q = _messageOutQueue;
            if (q == null || !q.TryTake(out message, -1))
                return;

            byte[] buffer;
            try
            {
                // Custom serialization
                buffer = CustomFormatter.Serialize(message);
            }
            catch (Exception e)
            {
                Log.Error("Invalid message to serialize, closing connection.", e);
                Stop();
                return;
            }

            lock (lockObject)
            {

                if (TcpSocket == null || !TcpSocket.Connected)
                {
                    Log.Error("Tried to send message " + message + " while not connected.");
                    return;
                }

                try
                {
                    TcpSocket.BeginSend(
                        buffer, 0, buffer.Length, 0,
                        new AsyncCallback(SendTcpCallback), this);
                }
                catch (SocketException se)
                {
                    Log.Error("Error sending, closing connection", se);
                    Stop();
                    return;
                }
            }
        }

        private static void SendTcpCallback(IAsyncResult ar)
        {
            var client = (Connection)ar.AsyncState;
            lock (client.lockObject)
            {
                if (client.TcpSocket == null)
                {
                    return;
                }

                try
                {
                    // Complete sending the data to the remote device.
                    client.TcpSocket.EndSend(ar);

                    // Send the next message
                    client.BeginSending();
                }
                catch (ArgumentException)
                {
                    // this is the result of a previous connection, we discard it
                    return;
                }
                catch (SocketException se)
                {
                    client.Log.Error("Error while sending, closing connection", se);
                    client.Stop();
                }
            }
        }

        public object PopNextMessage()
        {
            object message;
            var x = _messageInQueue;
            if (x == null)
                Log.Warn("Could not pop message, no queue");
            else if (!x.TryTake(out message))
                Log.Info("In queue of messages exhausted");
            else
                return message;
            return null;
        }

        public int MessageCount
        {
            get
            {
                var x = _messageInQueue;
                return x == null ? 0 : x.Count;
            }
        }
    }
}
